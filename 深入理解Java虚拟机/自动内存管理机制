第2章 Java内存区域与内存溢出异常
2.1 概述
    ·本章从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能
     产生的问题。


2.2 运行时数据区域
·划分：
    ·方法区（线程共享）
    ·堆（线程共享）
    ·虚拟机栈
    ·本地方法栈
    ·程序计数器

    2.2.1 程序计数器
    ·概念：程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当
     前线程所执行的字节码的行号指示器。如果线程正在执行的是一个Java方法，这个计数器记录
     的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为
     空（Undefined）。
    ·字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，
     分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    ·线程私有。Java多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，每条线程
     都需要有一个独立的程序计数器。
    ·此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

    2.2.2 Java虚拟机栈
    ·概念：虚拟机栈（Java Virtual Machine Stacks）描述的是Java方法执行的内存模型：每
     个方法在执行的同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态
     链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机
     栈中入栈到出栈的过程。
    ·线程私有。生命周期与线程相同。
    ·局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型。
        ·基本数据类型：boolean、byte、char、short、int、float、long、double。
        ·对象引用：reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用
         指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。
        ·returnAddress类型：指向了一条字节码指令的地址。
        ·其中long和double会占用2个局部变量空间（Slot），其余数据类型只占一个。
        ·所需内存空间在在编译期间完成分配。当进入一个方法时，这个方法需要在帧中分配多大
         的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
        ·两种异常情况：
            ·线程请求的栈深度大于虚拟机所允许的深度：StackOverflowError
            ·如果虚拟机栈可以动态扩展，且在扩展时无法申请到足够的内存：
             OutOfMemoryError

    2.2.3 本地方法栈
    ·概念：本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常类似的，他们
     之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为
     虚拟机使用到的Native方法服务。
    ·在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此
     具体的虚拟机可以自由实现它。有的虚拟机（如Sun HotSpot虚拟机）直接就把本地方法栈和
     虚拟机栈合二为一。

    2.2.4 Java堆
    ·概念：Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。此内存的唯一目的就
     是存放对象实例，几乎所有的对象实例都在这里分配内存。
    ·Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着JIT编译器的
     发展与逃逸分析技术逐渐成熟，这也变得不是那么绝对了。
    ·线程共享。在虚拟机启动时创建。可能划分出多个线程私有的分配缓冲区（Thread Local
     Allocation Buffer，TLAB）。无论如何划分，存储的都仍然是对象实例，进一步划分的目
     的是为了更好地回收内存，或者更快地分配内存。
    ·Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”（Garbage Collected
     Heap）。
    ·可细分为新生代和老生代。
    ·Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。
    ·可以是固定大小的，也可以是可扩展的。

    2.2.5 方法区
    ·概念：方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编
     译器编译后的代码等数据。
    ·Java虚拟机规范把方法区描述为堆的一个逻辑部分，但它却有一个别名叫做Non-Heap（非堆）
     ，目的应该是与Java堆区分开来。
    ·线程共享。
    ·如何实现方法区属于虚拟机实现细节，不收虚拟机规范约束。
    ·除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃
     圾收集。
    ·这区域的的内存回收目标主要是针对常量池的回收和对类型的卸载。
    ·当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。

    2.2.6 运行时常量池
    ·运行时常量池（Runtime Constant Pool）是方法区的一部分。
    ·Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池
     （Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将
     在类加载后进入方法区的运行时常量池中存放。
    ·Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每个字节用于
     存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池
     ，Java没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内
     存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接
     引用也存储在运行时常量池中。
    ·具有动态性。运行期间也可能将新的常量放入池中。如String类的intern()方法。

    2.2.7 直接内存
    ·直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中
     定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常
     的出现。受本机内存限制。


2.3 HotSpot虚拟机对象探秘
·以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象
 分配、布局和访问的全过程。

    2.3.1 对象的创建
    ·过程
        ·虚拟机遇到一条new指令时，首先将去检这个指令的参数是否能在常量池中定位到一个类
         的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有
         ，那必须先执行相应的类加载过程。
        ·在类加载检查通过后，接下来虚拟机将为新生对象分配内存。
            ·对象所需的内存大小在类加载完成后便可完全确定，为对象分配空间的任务等同于
             把一块确定大小的内存从Java堆中划分出来。
            ·两种分配方式：
                ·“指针碰撞”（Bump the Pointer）
                 内存是绝对规整的，指针指向用过的内存和空闲内存的分界点。
                ·“空闲列表”（Free List）
                 内存不是规整的，已使用的内存和空闲内存相互交错。虚拟机必须维护一个列
                 表记录哪些内存块是可用的。在分配时从列表中寻找足够大的内存。
            ·Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。
            ·解决并发情况下修改指针所造成的线程安全问题的方案：
                ·对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方
                 式保证更新操作的原子性。
                ·把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆
                 中预先分配一小块内存，成为本地线程缓冲（Thread Local Allocation
                 Buffer，TLAB）。线程在各自的TLAB上分配内存。只有TLAB用完并分配新的
                 TLAB时才需要同步锁定。虚拟机是否使用TLAB可通过-XX:+/-UseTLAB参数来
                 设定。
        ·内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如
         果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。
             ·这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就主机IE使用，程
             序能访问到这些字段的数据类型所对应的零值。
        ·接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到
         类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。
            ·这些对象存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态
             的不同，对象头会有不同的设置方式。
        ·经过以上步骤，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角
         来看，对象创建才刚刚开始——<init>方法还没有执行。

    2.3.2 对象的内存布局
    ·在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例
     数据（Instance Data）和对齐填充（Padding）。
    ·HotSpot虚拟机的对象头包括两部分信息：
        ·第一部分官方称它为“Mark Word”，用于存储对象自身的运行时数据。
            ·数据包括哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线
             程ID、偏向时间戳等。
            ·这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64
             bit。
        ·对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来
         确定这个对象是哪个类的实例。
            ·并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象
             的元数据信息并不一定要经过对象本身。
            ·如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，
             因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组
             的元数据中无法确定数组的大小。
    ·接下来的实例数据部分是对象真正存储的有效信息也是在程序代码中所定义的各种类型的字段
     内容。
        ·无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。
        ·这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在
         Java源码中定义顺序的影响。
            ·HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、
             bytes/booleans、oops(Ordinary Object Pointers)，从分配策略中可以看出，
             相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义
             的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那
             么子类之中较窄的变量也可能会插入到父类变量的空隙之中。
    ·第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
        ·由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说
         就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍。因此当对象
         实例数据部分没有对齐时，就需要通过对齐填充来补全。

    2.3.3 对象的访问定位
    ·建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体
     对象。目前主流的访问方式有使用句柄和直接指针两种。
        ·句柄访问：Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的
         句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息
        ·如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的
         相关信息，而reference中存储的直接就是对象地址。即reference中存储对象地址，对
         象中存储实例数据和对象类型数据的地址。
    ·对比：
        ·使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动
         （垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而
         reference本身不需要修改。
        ·使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。
    ·HotSpot使用第二种方式进行对象访问。
