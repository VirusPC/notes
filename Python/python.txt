一．Python基础
1.数据类型和变量
    ·整数
        ·Python可以处理任意大小的整数
    ·浮点数
    ·字符串
        · \ 为转义字符
        ·三个双引号或三个单引号中的回车会被当做\n,可用来显示多行内容
        ·在引号前加r如print(r"\n'''"),引号内的内容被当做纯字符串,加u则为unicode字符串
    ·布尔值
        ·值:True、False
        ·运算符:or、and、not  相当于 Java中的 &&、||、！
    ·空值
        ·None
    ·可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量
    ·除法运算
        ·/为除号，得到浮点数
        ·//为地板除，结果向下取整
        ·%取余
    ·定义变量机制类似JavaScript省略var

2.字符串和编码
    ·编码类型:
        ·最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号,这个编
         码表被称为ASCII编码。
        ·要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，
         所以，中国制定了GB2312编码，用来把中文编进去。
        ·UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母
         被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。
    ·计算机系统通用的字符编码工作方式：
        ·在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转
         换为UTF-8编码。
        ·用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完
         成后，保存的时候再把Unicode转换为UTF-8保存到文件：
        ·浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。
    ·Python的字符串
        ·在最新的Python 3版本中，字符串是以Unicode编码的。
        ·对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码
         转换为对应的字符：
            ·ord('A') == 65
            ·chr(66) == 'B'
        ·对bytes类型的数据用带b前缀的单引号或双引号表示：
            ·x = b'ABC'
            ·要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但
             bytes的每个字符都只占用一个字节。
        ·以Unicode表示的str通过encode()方法可以编码为指定的bytes：
            ·'ABC'.encode('ascii') == b'ABC'
            ·'中文'.encode('utf-8') == b'\xe4\xb8\xad\xe6\x96\x87'
            ·'中文'.encode('ascii') #error
        ·如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为
         str，就需要用decode()方法：
            ·b'ABC'.decode('ascii') == 'ABC'
            ·b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8') == '中文'
            ·如果bytes中只有一小部分无效的字节,可以传入errors='ignore'忽略错误的字节
        ·要计算str包含多少个字符，可以用len()函数：
            ·len(b'ABC') == 3
            ·len(b'\xe4\xb8\xad\xe6\x96\x87') == 6
            ·len('中文'.encode('utf-8')) == 6
        ·当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上：
            ·#!/usr/bin/env python3
             # -*- coding: utf-8 -*-
            ·第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows
             系统会忽略这个注释；
            ·第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码
        ·使用 % 来格式化字符串
            ·>>>'Hi, %s, you have $%d.' % ('Michael', 1000000)
                'Hi, Michael, you have $1000000.'
            ·>>>print('%02d-%2d' % (3, 1))
                03- 1
            ·%s永远起作用，它会把任何数据类型转换为字符串：
        ·另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换
         字符串内的占位符{0}、{1}……
            ·>>>'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
                'Hello, 小明, 成绩提升了 17.1%'

3.使用list和tuple
    ·list
        ·>>> classmates = ['Michael', 'Bob', 'Tracy']
         >>> classmates
         ['Michael', 'Bob', 'Tracy']
        ·要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素
        ·把元素插入到指定的位置
            ·classmates.insert(1, 'Jack')
        ·于在列表末尾添加新的对象。
            ·list.append('Nicholas')
        ·删除list末尾的元素
            ·classmates.pop()
        ·删除指定位置的元素
            ·classmates.pop(1)
        ·要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
            ·classmates[1] = 'Sarah'
        ·list里面的元素的数据类型可以不同
    ·tuple
        ·另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能
         修改，代码更安全。
        ·>>> classmates = ('Michael', 'Bob', 'Tracy')
        ·要定义一个只有1个元素的tuple，如果你这么定义
         >>> t = (1)
         >>> t
         1
         定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公
         式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算
         ，计算结果自然是1。
        ·Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义
         上的括号。
        ·“可变的”tuple：
            ·>>> t = ('a', 'b', ['A', 'B'])
             >>> t[2][0] = 'X'
             >>> t[2][1] = 'Y'
             >>> t
             ('a', 'b', ['X', 'Y'])

4.条件判断
    ·if age >= 18:
         print('adult')
     elif age >= 6:
         print('teenager')
     else:
         print('kid')
    ·如果if语句判断是True，就把缩进的print语句执行了，否则，什么也不做。
    ·if判断条件还可以简写，比如写：
        if x:
            print('True')
     只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。
    ·input
        ·input()返回的数据类型是str，可用int()或float()来转换为数字

5.循环
    ·for循环
        ·names = ['Michael', 'Bob', 'Tracy']
         for name in names:
             print(name)
        ·for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。
        ·Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为
         list。比如range(5)生成的序列是从0开始小于5的整数：
            list(range(5))
            [0, 1, 2, 3, 4]
        ·计算0~100之和
            sum = 0
            for x in range(101):
            sum = sum + x
            print(sum)
    ·while循环
        ·计算100以内所有奇数之和
         sum = 0
         n = 99
         while n > 0:
             sum = sum + n
             n = n - 2
         print(sum)
    ·break 用法同C语言、Java等
    ·continue 用法同C语言，Java等

6.使用dict和set
    ·dict
        ·Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使
         用键-值（key-value）存储，具有极快的查找速度。
        ·>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
         >>> d['Michael']
         95
        ·把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
         d['Adam'] = 67
        ·由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面
         的值冲掉
        ·如果key不存在，dict就会报错要避免key不存在的错误，有两种办法
            ·一是通过in判断key是否存在。
                >>> 'Thomas' in d
                False
            ·二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的
             value
                d.get('Thomas')
                >>> d.get('Thomas', -1)
                -1
            ·dict内部存放的顺序和key放入的顺序是没有关系的。
        ·和list比较，dict有以下几个特点：
            ·dict查找和插入的速度极快，不会随着key的增加而变慢；list查找和插入的时间
             随着元素的增加而增加；
            ·dict需要占用大量的内存，内存浪费多；list相反
    ·set
        ·set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在
         set中，没有重复的key。
        ·要创建一个set，需要提供一个list作为输入集合
            >>> s = set([1, 2, 3])
            >>> s
            {1, 2, 3}
        ·通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果
        ·通过remove(key)方法可以删除元素
        ·set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上
         的交集、并集等操作
            >>> s1 = set([1, 2, 3])
            >>> s2 = set([2, 3, 4])
            >>> s1 & s2
            {2, 3}
            >>> s1 | s2
            {1, 2, 3, 4}
    ·再议不可变对象
        ·对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：
            >>> a = ['c', 'b', 'a']
            >>> a.sort()
            >>> a
            ['a', 'b', 'c']
        ·而对于不可变对象，比如str，虽然字符串有个replace()方法，也确实变出了'Abc'，
         但变量a最后仍是'abc'。对于不变对象来说，调用对象自身的任意方法，也不会改变该
         对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本
         身永远是不可变的。
            >>> a = 'abc'
            >>> b = a.replace('a', 'A')
            >>> b
            'Abc'
            >>> a
            'abc'


二. 函数
1.调用函数
    ·abs(n)，求n的绝对值，同Java
    ·max(n1, n2 ...),接收任意多个参数，并返回最大的那个,Java固定接收两个参数
    ·min(n1, n2 ...),接收任意多个参数，并返回最小的那个,Java固定接收两个参数
    ·数据类型转换，可传入多种类型的参数
        ·int()
        ·float()
        ·str()
        ·bool()
        ·hex()
    ·函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，
     相当于给这个函数起了一个“别名”：
        >>> a = abs # 变量a指向abs函数
        >>> a(-1) # 所以也可以通过a调用abs函数
        1

2.定义函数
    ·在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:
     ，然后，在缩进块中编写函数体，函数的返回值用return语句返回。
        def my_abs(x):
            if x >= 0:
             return x
            else:
             return -x
        print(my_abs(-99))
    ·在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次
     回车重新回到>>>提示符下
    ·如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目
     录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意
     abstest是文件名（不含.py扩展名）
        >>> from abstest import my_abs
        >>> my_abs(-9)
        9
    ·如果想定义一个什么事也不做的空函数，可以用pass语句：
        ·def nop():
             pass
        ·if age >= 18:
             pass
    ·对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数
     isinstance()实现
        ·参数类型做检查，只允许整数和浮点数类型的参数
            def my_abs(x):
            if not isinstance(x, (int, float)):
                raise TypeError('bad operand type')
            if x >= 0:
                return x
            else:
                return -x
    ·返回多个值
        ·   import math

            def move(x, y, step, angle=0):
                nx = x + step * math.cos(angle)
                ny = y - step * math.sin(angle)
                return nx, ny

            x, y = move(100, 100, 60, math.pi / 6)
            print(x, y)
        ·返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以
         同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回
         一个tuple，但写起来更方便。

3.函数的参数
    ·位置参数
        ·def power(x, n):
             s = 1
             while n > 0:
                 n = n - 1
                 s = s * x
             return s
    ·默认参数
        ·必选参数在前，默认参数在后
        ·def power(x, n=2):
         s = 1
         while n > 0:
             n = n - 1
             s = s * x
         return s
        ·调用power(5)时，相当于调用power(5, 2)
        · 定义默认参数要牢记一点：默认参数必须指向不变对象！
            ·def add_end(L=[]):
                 L.append('END')
                 return L
            ·>>> add_end()
             ['END']
             >>> add_end()
             ['END', 'END']
            ·Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L
             也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用
             时，默认参数的内容就变了，不再是函数定义时的[]了。
    ·可变参数
        ·定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数
         内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函
         数时，可以传入任意个参数，包括0个参数。
            ·def calc(*numbers):
             sum = 0
             for n in numbers:
                 sum = sum + n * n
             return sum
            ·>>> calc(1, 2)
             5
             >>> calc()
             0
        ·Python允许在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去
            ·>>> nums = [1, 2, 3]
             >>> calc(*nums)
             14
    ·关键字参数
        ·可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个
         tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数
         内部自动组装为一个dict。
        ·def person(name, age, **kw):
            print('name:', name, 'age:', age, 'other:', kw)
        ·函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以
         只传入必选参数，也可以传入任意个数的关键字参数
            ·>>> person('Michael', 30)
             name: Michael age: 30 other: {}
            ·>>> person('Bob', 35, city='Beijing')
             name: Bob age: 35 other: {'city': 'Beijing'}
             >>> person('Adam', 45, gender='M', job='Engineer')
             name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
        ·**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，
         kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函
         数外的extra。
            ·>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
             >>> person('Jack', 24, **extra)
    ·命名关键字参数
        ·对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪
         些，就需要在函数内部通过kw检查
            ·def person(name, age, **kw):
                 if 'city' in kw:
                     # 有city参数
                     pass
                 if 'job' in kw:
                     # 有job参数
                     pass
                 print('name:', name, 'age:', age, 'other:', kw)
        ·如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为
         关键字参数。这种方式定义的函数如下：
            ·def person(name, age, *, city, job):
                 print(name, age, city, job)
        ·和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命
         名关键字参数。调用方式如下：
            ·>>> person('Jack', 24, city='Beijing', job='Engineer')
             Jack 24 Beijing Engineer
        ·如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊
         分隔符*了：
            ·def person(name, age, *args, city, job):
                 print(name, age, args, city, job)
        ·命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错
    ·参数组合
        ·在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键
         字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、
         默认参数、可变参数、关键字参数和命名关键字参数。
        ·通过一个tuple和dict，你也可以调用上述函数：
    ·总结
        ·定义可变参数和关键字参数的语法：
            ·*args是可变参数，args接收的是一个tuple
            ·**kw是关键字参数，kw接收的是一个dict
        ·用函数时如何传入可变参数和关键字参数的语法：
            ·可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过
             *args传入：func(*(1, 2, 3))；
            ·关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw
             传入：func(**{'a': 1, 'b': 2})。
            ·使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯
             用法。
            ·命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
            ·定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将
            是位置参数。

4.递归函数
    ·使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
    ·针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环
     语句的编程语言只能通过尾递归实现循环。
    ·Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。


三.高级特性
1.切片
    ·L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
        ·取索引为 0,1,2 的三个元素：
            >>> L[0:3] # 相当于L[:3]
            ['Michael', 'Sarah', 'Tracy']
        ·从索引1开始，取出2个元素：
            >>> L[1:3]
            ['Sarah', 'Tracy']
        ·倒数切片：
            >>> L[-2:]
            ['Bob', 'Jack']
            >>> L[-2:-1]
            ['Bob']
    ·L = list(range(100))
        ·前10个数，每两个取一个：
            >>> L[:10:2]
            [0, 2, 4, 6, 8]
        ·所有数，每5个取一个：
            >>> L[::5]
            [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80,
            85, 90, 95]
        ·原样复制一个list：
            >>> L[:]
            [0, 1, 2, 3, ..., 99]
    ·tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作
     的结果仍是tuple
         >>> (0, 1, 2, 3, 4, 5)[:3]
         (0, 1, 2)
    ·字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操
     作，只是操作结果仍是字符串：
         >>> 'ABCDEFG'[:3]
        'ABC'
        >>> 'ABCDEFG'[::2]
        'ACEG'
    ·不会发生 “string index out of range” 错误，根据实际情况自适应
        >>> s = '12345'
        >>> s[:100]
        '12345'

2.迭代
    ·如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，
     这种遍历我们称为迭代（Iteration）。
    ·只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代。因为dict的存储不
     是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。
        >>> d = {'a': 1, 'b': 2, 'c': 3}
        >>> for key in d:
        ...     print(key)
        ...
        a
        c
        b
    ·默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，
     如果要同时迭代key和value，可以用for k, v in d.items()。
    ·由于字符串也是可迭代对象，因此，也可以作用于for循环：
        >>> for ch in 'ABC':
        ...     print(ch)
        ...
        A
        B
        C
    ·通过collections模块的Iterable类型判断一个对象是可迭代对象
        >>> from collections import Iterable
        >>> isinstance('abc', Iterable) # str是否可迭代
        True
        >>> isinstance([1,2,3], Iterable) # list是否可迭代
        True
        >>> isinstance(123, Iterable) # 整数是否可迭代
        False
    ·如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一
     个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：
        >>> for i, value in enumerate(['A', 'B', 'C']):
        ...     print(i, value)
        ...
        0 A
        1 B
        2 C
    ·上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：
        >>> for x, y in [(1, 1), (2, 4), (3, 9)]:
        ...     print(x, y)
        ...
        1 1
        2 4
        3 9

3.列表生成式
    ·列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list
     的生成式。
    ·生成list[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        list(range(1, 11))
    ·生成[1*1, 2*2, 3*3, ..., 10*10]
        [x * x for x in range(1, 11)]
    ·写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来
    ·for循环后面还可以加上if判断
        ·筛选出仅偶数的平方：
            [x * x for x in range(1, 11) if x % 2 == 0]
    ·使用两层循环生成全排列
        [m + n for m in 'ABC' for n in 'XYZ']
    ·列出当前目录下的所有文件和目录名
        import os
        [d for d in os.listdir('.')]
    ·for循环可以同时使用两个甚至多个变量，列表生成式也可以使用两个变量来生成list
        d = {'x': 'A', 'y': 'B', 'z': 'C' }
        [k + '=' + v for k, v in d.items()]
    ·   L1 = ['Hello', 'World', 18, 'Apple', None]
        L2 = [x.lower() for x in L1 if isinstance(x, str)]

4.生成器
    ·通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。
     而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问
     前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。Python中，列表元素可以按
     照某种算法推算出来，不必创建完整的list，从而节省大量的空间这种一边循环一边计算的机
     制，称为生成器：generator。
    ·generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最
     后一个元素，没有更多的元素时，抛出StopIteration的错误。
    ·第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：
            >>> g = (x * x for x in range(10))
            >>> g
            <generator object <genexpr> at 0x1022ef630>
        ·如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：
            >>> next(g)
            0
            >>> next(g)
            1
            >>> next(g)
            4
        ·循环打印
            for n in g:
               print(n)
    ·定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再
     是一个普通函数，而是一个generator
            def odd():
                print('step 1')
                yield 1
                print('step 2')
                yield(3)
                print('step 3')*
                yield(5)
        ·函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的
         函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的
         yield语句处继续执行。
        ·调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下
         一个返回值，第4次调用next(o)时报错
    ·但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要
     拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：

5.迭代器
    ·可以直接作用于for循环的对象统称为可迭代对象：Iterable。其数据类型有以下几种：
        ·一类是集合数据类型，如list、tuple、dict、set、str等；
        ·一类是generator，包括生成器和带yield的generator function。
        ·可以使用isinstance()判断一个对象是否是Iterable对象：
            >>> from collections import Iterable
            >>> isinstance([], Iterable)
            True
    ·可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。
        ·生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到
         最后抛出StopIteration错误表示无法继续返回下一个值了。
        ·可以使用isinstance()判断一个对象是否是Iterator对象：
            >>> from collections import Iterator
            >>> isinstance((x fo
            r x in range(10)), Iterator)
            True
    ·生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。
    ·Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断
     返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有
     序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个
     数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。
    ·集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数
     获得一个Iterator对象。
    ·Python的for循环本质上就是通过不断调用next()函数实现的


四.函数式编程
1.高阶函数
    ·概念
        ·变量可以指向函数
        ·函数名也是变量
        ·传入函数
        ·   def add(x, y, f):
            return f(x) + f(y)
            print(add(-5, 6, abs))
    ·map/reduce
        ·map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator
         是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。
             def f(x):
                 return x * x
             r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
             # [1, 4, 9, 16, 25, 36, 49, 64, 81]
        ·reduce()把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参
         数，reduce把结果继续和序列的下一个元素做累积计算
            ·from functools import reduce
            ·reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
    ·filter
        ·Python内建的filter()函数用于过滤序列。
        ·和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把
         传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该
         元素。
            def is_odd(n):
            return n % 2 == 1
            list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
        ·filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完
         成计算结果，需要用list()函数获得所有结果并返回list。
    ·sorted
        ·直接排序
            >>> sorted([36, 5, -12, 9, -21])
            [-21, -12, 5, 9, 36]
        ·接收一个key函数来实现自定义的排序
            >>> sorted([36, 5, -12, 9, -21], key=abs)
            [5, 9, -12, -21, 36]
        ·要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True
            >>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, \
            ... reverse=True)
            ['Zoo', 'Credit', 'bob', 'about']

2.返回函数
    ·函数作为返回值
        ·如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的
         结果，而是返回求和的函数：
            def lazy_sum(*args):
                def sum():
                    ax = 0
                    for n in args:
                        ax = ax + n
                    return ax
                return sum
        ·当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：
            >>> f = lazy_sum(1, 3, 5, 7, 9)
            >>> f
            <function lazy_sum.<locals>.sum at 0x101c6ed90>
        ·调用函数f时，才真正计算求和的结果：
            >>> f()
            25
        ·在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用
         外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都
         保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
        ·当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数。
    ·闭包
        ·注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函
         数后，其内部的局部变量还被新函数引用。
        ·另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。
                def count():
                    fs = []
                    for i in range(1, 4):
                        def f():
                             return i*i
                        fs.append(f)
                    return fs

                f1, f2, f3 = count()
            ·调用f1()，f2()和f3()的结果
                >>> f1()
                9
                >>> f2()
                9
                >>> f3()
                9
            ·全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数
             都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。
        ·返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
        ·如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量
         当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
             def count():
                 def f(j):
                     def g():
                         return j*j
                     return g
                 fs = []
                 for i in range(1, 4):
                     fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
                 return fs
    ·利用闭包和生成器返回一个计数器函数，每次调用它返回递增整数：
        def create_counter():
            def counter():
                def lt():
                    mm = 0
                    while True:
                        mm += 1
                        yield mm
                g = lt()

                def inner():
                    return next(g)
                return inner
            return counter()

        counterA = create_counter()
        print(type(counterA))
        print(counterA(), counterA(), counterA(), counterA(), counterA())
        # 1 2 3 4 5

3.匿名函数
    ·在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定
     义一个f(x)的函数外，还可以直接传入匿名函数：
         >>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
         [1, 4, 9, 16, 25, 36, 49, 64, 81]
    ·匿名函数lambda x: x * x实际上就是：
        def f(x):
        return x * x
    ·关键字lambda表示匿名函数，冒号前面的x表示函数参数。
    ·匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

4.装饰器（Decorator）
    ·由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。
            >>> def now():
            ...     print('2015-3-25')
            ...
            >>> f = now
            >>> f()
            2015-3-25
        ·函数对象有一个__name__属性，可以拿到函数的名字：
            >>> now.__name__
            'now'
            >>> f.__name__
            'now'
    ·现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望
     修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”
     （Decorator）。
        ·本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的
         decorator，可以定义如下：
             def log(func):
                 def wrapper(*args, **kw):
                     print('call %s():' % func.__name__)
                     return func(*args, **kw)
                 return wrapper
        ·观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函
         数。我们要借助Python的@语法，把decorator置于函数的定义处：
            @log
            def now():
                print('2015-3-25')
        ·调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：
            >>> now()
            call now():
            2015-3-25
        ·把@log放到now()函数的定义处，相当于执行了语句：
            now = log(now)
        ·由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是
         现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中
         返回的wrapper()函数。
        ·wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数
         的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。
    ·如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，比如，要
     自定义log的文本：
            def log(text):
                def decorator(func):
                    def wrapper(*args, **kw):
                        print('%s %s():' % (text, func.__name__))
                        return func(*args, **kw)
                    return wrapper
                return decorator
        ·这个3层嵌套的decorator用法如下：
            @log('execute')
            def now():
                print('2015-3-25')
        ·执行结果如下：
            >>> now()
            execute now():
            2015-3-25
        ·和两层嵌套的decorator相比，3层嵌套的效果是这样的：
            >>> now = log('execute')(now)
        ·首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now
         函数，返回值最终是wrapper函数。
    ·以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有
     __name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的
     'now'变成了'wrapper'：
            >>> now.__name__
            'wrapper'
        ·因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的
         __name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出
         错。
    ·不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的
     functools.wraps就是干这个事的。
        ·一个完整的不带参数的decorator的写法如下：
            import functools
            def log(func):
                @functools.wraps(func)
                def wrapper(*args, **kw):
                    print('call %s():' % func.__name__)
                    return func(*args, **kw)
                return wrapper
        ·带参数的decorator：
            import functools
            def log(text):
                def decorator(func):
                    @functools.wraps(func)
                    def wrapper(*args, **kw):
                        print('%s %s():' % (text, func.__name__))
                        return func(*args, **kw)
                    return wrapper
                return decorator

5.偏函数（Partial function）
    ·通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。
        ·int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换
            >>> int('12345')
            12345
        ·但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制
         的转换：
            >>> int('12345', base=8)
            5349
            >>> int('12345', 16)
            74565
        ·假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想
         到，可以定义一个int2()的函数，默认把base=2传进去：
            ·def int2(x, base=2):
                 return int(x, base)
            ·>>> int2('1000000')
             64
             >>> int2('1010101')
             85
    ·functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直
     接使用下面的代码创建一个新的函数int2：
        >>> import functools
        >>> int2 = functools.partial(int, base=2)
        >>> int2('1000000')
        64
        >>> int2('1010101')
        85
    ·所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是
     设置默认值），返回一个新的函数，调用这个新函数会更简单。
    ·创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数
        ·int2('10010')
         相当于
         kw = { 'base': 2 }
         int('10010', **kw)
        ·max2 = functools.partial(max, 10)
         max2(5, 6, 7)
         相当于
         args = (10, 5, 6, 7)
         max(*args)


五.模块
1.概念
    ·一个.py文件就称之为一个模块（Module）。
    ·为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。
        ·一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的
         模块。
        ·假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模
         块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：
            mycompany
            ├─ __init__.py
            ├─ abc.py
            └─ xyz.py
        ·现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了
         mycompany.xyz。
    ·每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python
     就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python
     代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。
    ·注意事项
        ·模块名要遵循Python变量命名规范，不要使用中文、特殊字符；
        ·模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在
         Python交互环境执行import abc，若成功则说明系统存在此模块。

2.使用模块
    ·当我们在命令行运行模块文件时，Python解释器把该模块中的一个特殊变量__name__置为
     __main__
    ·sys模块
        ·import sys
        ·导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模
         块的所有功能。
        ·sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因
         为第一个参数永远是该.py文件的名称
            ·运行python3 hello.py获得的sys.argv就是['hello.py']
    ·在import的时候就会执行里面的代码
        >>> import hello2.py
        hello helllow.py
    ·作用域
        ·在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用
         ，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。
        ·正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等
        ·类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的
         __author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量
         __doc__访问，我们自己的变量一般不要用这种变量名
        ·类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比
         如_abc，__abc等
        ·private函数和变量“不应该”被直接引用，而不是“不能”被直接引用。Python并没有一
         种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用
         private函数或变量。

3.安装第三方模块
