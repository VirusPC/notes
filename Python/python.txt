一．Python基础
1.数据类型和变量
    ·整数
        ·Python可以处理任意大小的整数
    ·浮点数
    ·字符串
        · \ 为转义字符
        ·三个双引号或三个单引号中的回车会被当做\n,可用来显示多行内容
        ·在引号前加r如print(r"\n'''"),引号内的内容被当做纯字符串,加u则为unicode字符串
    ·布尔值
        ·值:True、False 相当于Java、js中的true、false
        ·运算符:or、and、not  相当于Java中的 &&、||、！
    ·空值
        ·None 相当于Java中的Null
    ·可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量
    ·除法运算
        ·/为除号，得到浮点数
        ·//为地板除，结果向下取整
        ·%取余
    ·动态语言，定义变量机制类似JavaScript省略var, 不必先定义后使用

2.字符串和编码
    ·编码类型:
        ·最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号,这个编
         码表被称为ASCII编码。
        ·要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，
         所以，中国制定了GB2312编码，用来把中文编进去。
        ·UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母
         被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。
    ·计算机系统通用的字符编码工作方式：
        ·在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转
         换为UTF-8编码。
        ·用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完
         成后，保存的时候再把Unicode转换为UTF-8保存到文件：
        ·浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。
    ·Python的字符串
        ·在最新的Python 3版本中，字符串是以Unicode编码的。
        ·对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码
         转换为对应的字符：
            ·ord('A') == 65
            ·chr(66) == 'B'
        ·对bytes类型的数据用带b前缀的单引号或双引号表示：
            ·x = b'ABC'
            ·要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但
             bytes的每个字符都只占用一个字节。
        ·以Unicode表示的str通过encode()方法可以编码为指定的bytes：
            ·'ABC'.encode('ascii') == b'ABC'
            ·'中文'.encode('utf-8') == b'\xe4\xb8\xad\xe6\x96\x87'
            ·'中文'.encode('ascii') #error
        ·如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为
         str，就需要用decode()方法：
            ·b'ABC'.decode('ascii') == 'ABC'
            ·b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8') == '中文'
            ·如果bytes中只有一小部分无效的字节,可以传入errors='ignore'忽略错误的字节
        ·要计算str包含多少个字符，可以用len()函数：
            ·len(b'ABC') == 3
            ·len(b'\xe4\xb8\xad\xe6\x96\x87') == 6
            ·len('中文'.encode('utf-8')) == 6
        ·当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上：
            ·#!/usr/bin/env python3
             # -*- coding: utf-8 -*-
            ·第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows
             系统会忽略这个注释；
            ·第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码
        ·使用 % 来格式化字符串
            ·>>>'Hi, %s, you have $%d.' % ('Michael', 1000000)
                'Hi, Michael, you have $1000000.'
            ·>>>print('%02d-%2d' % (3, 1))
                03- 1
            ·%s永远起作用，它会把任何数据类型转换为字符串：
        ·另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换
         字符串内的占位符{0}、{1}……
            ·>>>'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
                'Hello, 小明, 成绩提升了 17.1%'
        ·将字符串str重复输出n次
            ·print(str * n)
        ·print自带换行，若不想换行需设置end属性
            ·print('contents', end='')
        ·in/not in
            ·判断字符串str1中是否包含另一个字符串str2
            ·str2 in str1
            ·str2 not in str1
        ·count函数
            ·统计字符串里某个字符串的出现次数
            ·print(str.count('i'))
        ·endswith函数
            ·判断是否以某个字符串为后缀
            ·print(str.endswith('afa'))
        ·find/index函数
            ·检测字符串中是否包含子字符串str，返回索引值，类似java中的indexOf
            ·print(str.index('love'))
            ·index()方法在没有找到指定字符串的时候会抛出异常. 
            ·另外,index()也可以用于List对象,返回指定元素的索引,用法相同.
        ·replace函数
            ·替换，同java
            ·newstr = str.replace('china', 'nanning')
        ·split函数
            ·同java6
    ·java
        String string = "test";
        byte[] bs = string.getBytes("GBK");
        string = new String(bs, "UTF-8");

3.使用list和tuple
    ·list
        ·>>> classmates = ['Michael', 'Bob', 'Tracy']
         >>> classmates
         ['Michael', 'Bob', 'Tracy']
        ·要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素
        ·把元素插入到指定的位置
            ·classmates.insert(1, 'Jack')
        ·于在列表末尾添加新的对象。
            ·list.append('Nicholas')
        ·删除list末尾的元素
            ·classmates.pop()
        ·删除指定位置的元素
            ·classmates.pop(1)
        ·要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
            ·classmates[1] = 'Sarah'
        ·list里面的元素的数据类型可以不同
    ·tuple
        ·另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能
         修改，代码更安全。
        ·>>> classmates = ('Michael', 'Bob', 'Tracy')
        ·要定义一个只有1个元素的tuple，如果你这么定义
         >>> t = (1)
         >>> t
         1
         定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公
         式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算
         ，计算结果自然是1。
        ·Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义
         上的括号。
        ·“可变的”tuple：
            ·>>> t = ('a', 'b', ['A', 'B'])
             >>> t[2][0] = 'X'
             >>> t[2][1] = 'Y'
             >>> t
             ('a', 'b', ['X', 'Y'])

4.条件判断
    ·if age >= 18:
         print('adult')
     elif age >= 6:
         print('teenager')
     else:
         print('kid')
    ·如果if语句判断是True，就把缩进的print语句执行了，否则，什么也不做。
    ·if判断条件还可以简写，比如写：
        if x:
            print('True')
     只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。
    ·input
        ·input()返回的数据类型是str，可用int()或float()来转换为数字

5.循环
    ·for循环
        ·names = ['Michael', 'Bob', 'Tracy']
         for name in names:
             print(name)
        ·for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。
        ·Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为
         list。比如range(5)生成的序列是从0开始小于5的整数：
            list(range(5))
            [0, 1, 2, 3, 4]
        ·计算0~100之和
            sum = 0
            for x in range(101):
            sum = sum + x
            print(sum)
    ·while循环
        ·计算100以内所有奇数之和
         sum = 0
         n = 99
         while n > 0:
             sum = sum + n
             n = n - 2
         print(sum)
    ·break 用法同C语言、Java等
    ·continue 用法同C语言，Java等

6.使用dict和set
    ·dict
        ·Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使
         用键-值（key-value）存储，具有极快的查找速度。
        ·>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
        ·>>> d = dict(Michael=95, Bob=75, Tracy=85)
         >>> d['Michael']
         95
        ·把数据放入dict的方法，除了初始化时指定外，还可以通过key放入；java需要调用
         put()方法：
            d['Adam'] = 67
        ·由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面
         的值冲掉
        ·如果key不存在，dict就会报错要避免key不存在的错误，有两种办法
            ·一是通过in判断key是否存在。
                >>> 'Thomas' in d
                False
            ·二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的
             value
                d.get('Thomas')
                >>> d.get('Thomas', -1)
                -1
            ·dict内部存放的顺序和key放入的顺序是没有关系的。
        ·遍历
            ·>>>for key in d : # 相当于 for key in d.keys() :
            ·>>>for value in d.values() :
            ·遍历字典项
             >>>for kv in d.items() :
             ...    print(kv)
             ...
             ('Michael', 95)
             ('Bob', 75)
             ('Tracy', 85)
            ·遍历字典键值
                ·>>>for k, v in d.items() :
                 ...    print(k + ' ' + v)
                 ...
                 Michael 95
                 Bob 75
                 Tracy 85
                ·>>>for (k, v) in d.items() :
                 ...    print(k + ' ' + v)
                 ...
                 Michael 95
                 Bob 75
                 Tracy 85


        ·和list比较，dict有以下几个特点：
            ·dict查找和插入的速度极快，不会随着key的增加而变慢；list查找和插入的时间
             随着元素的增加而增加；
            ·dict需要占用大量的内存，内存浪费多；list相反
    ·set
        ·set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在
         set中，没有重复的key。
        ·要创建一个set，需要提供一个list作为输入集合
            >>> s = set([1, 2, 3]) # s = set{1, 2, 3}
            >>> s
            {1, 2, 3}
        ·通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果；
         list通过insert或append
        ·通过remove(key)方法可以删除元素；list通过pop
        ·set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上
         的交集、并集等操作
            >>> s1 = set([1, 2, 3])
            >>> s2 = set([2, 3, 4])
            >>> s1 & s2
            {2, 3}
            >>> s1 | s2
            {1, 2, 3, 4}
    ·再议不可变对象
        ·对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：
            >>> a = ['c', 'b', 'a']
            >>> a.sort()
            >>> a
            ['a', 'b', 'c']
        ·而对于不可变对象，比如str，虽然字符串有个replace()方法，也确实变出了'Abc'，
         但变量a最后仍是'abc'。对于不变对象来说，调用对象自身的任意方法，也不会改变该
         对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本
         身永远是不可变的。
            >>> a = 'abc'
            >>> b = a.replace('a', 'A') # 同java
            >>> b
            'Abc'
            >>> a
            'abc'


二. 函数
1.调用函数
    ·abs(n)，求n的绝对值，同Java
    ·max(n1, n2 ...),接收任意多个参数，并返回最大的那个,Java固定接收两个参数
    ·min(n1, n2 ...),接收任意多个参数，并返回最小的那个,Java固定接收两个参数
    ·数据类型转换，可传入多种类型的参数
        ·int()
        ·float()
        ·str()
        ·bool()
        ·hex()
    ·函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，
     相当于给这个函数起了一个“别名”：
        >>> a = abs # 变量a指向abs函数
        >>> a(-1) # 所以也可以通过a调用abs函数
        1

2.定义函数
    ·在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:
     ，然后，在缩进块中编写函数体，函数的返回值用return语句返回。
        ·python
         def my_abs(x):
             if x >= 0:
                 return x
             else:
                 return -x
         print(my_abs(-99))
        ·js
         function my_abs(x) {...}
    ·在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次
     回车重新回到>>>提示符下
    ·如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目
     录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意
     abstest是文件名（不含.py扩展名）
        >>> from abstest import my_abs
        >>> my_abs(-9)
        9
    ·如果想定义一个什么事也不做的空函数，可以用pass语句：
        ·def nop():
             pass
        ·if age >= 18:
             pass
    ·对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数
     isinstance()实现
        ·参数类型做检查，只允许整数和浮点数类型的参数
            def my_abs(x):
                if not isinstance(x, (int, float)):
                    raise TypeError('bad operand type')
                if x >= 0:
                    return x
                else:
                    return -x
    ·返回多个值
        ·   import math

            def move(x, y, step, angle=0):
                nx = x + step * math.cos(angle)
                ny = y - step * math.sin(angle)
                return nx, ny

            x, y = move(100, 100, 60, math.pi / 6)
            print(x, y)
        ·返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以
         同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回
         一个tuple，但写起来更方便。

3.函数的参数
    ·位置参数
        ·def power(x, n):
             s = 1
             while n > 0:
                 n = n - 1
                 s = s * x
             return s
    ·默认参数
        ·必选参数在前，默认参数在后
        ·def power(x, n=2):
         s = 1
         while n > 0:
             n = n - 1
             s = s * x
         return s
        ·调用power(5)时，相当于调用power(5, 2)
        · 定义默认参数要牢记一点：默认参数必须指向不变对象！
            ·def add_end(L=[]):
                 L.append('END')
                 return L
            ·>>> add_end()
             ['END']
             >>> add_end()
             ['END', 'END']
            ·Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L
             也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用
             时，默认参数的内容就变了，不再是函数定义时的[]了。
    ·可变参数
        ·定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数
         内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函
         数时，可以传入任意个参数，包括0个参数。
            ·def calc(*numbers):
                 sum = 0
                 for n in numbers:
                     sum = sum + n * n
                 return sum
            ·>>> calc(1, 2)
             5
             >>> calc()
             0
        ·Python允许在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去
            ·>>> nums = [1, 2, 3]
             >>> calc(*nums)
             14
    ·关键字参数
        ·可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个
         tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数
         内部自动组装为一个dict。
        ·def person(name, age, **kw):
            print('name:', name, 'age:', age, 'other:', kw)
        ·函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以
         只传入必选参数，也可以传入任意个数的关键字参数
            ·>>> person('Michael', 30)
             name: Michael age: 30 other: {}
            ·>>> person('Bob', 35, city='Beijing')
             name: Bob age: 35 other: {'city': 'Beijing'}
             >>> gender='M'
             >>> person('Adam', 45, gender=gender, job='Engineer')
             name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
        ·**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，
         kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函
         数外的extra。
            ·>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
             >>> person('Jack', 24, **extra)
    ·命名关键字参数
        ·对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪
         些，就需要在函数内部通过kw检查
            ·def person(name, age, **kw):
                 if 'city' in kw:
                     # 有city参数
                     pass
                 if 'job' in kw:
                     # 有job参数
                     pass
                 print('name:', name, 'age:', age, 'other:', kw)
        ·如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为
         关键字参数。这种方式定义的函数如下：
            ·def person(name, age, *, city, job):
                 print(name, age, city, job)
        ·和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命
         名关键字参数。调用方式如下：
            ·>>> person('Jack', 24, city='Beijing', job='Engineer')
             Jack 24 Beijing Engineer
        ·如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊
         分隔符*了：
            ·def person(name, age, *args, city, job):
                 print(name, age, args, city, job)
        ·命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错
    ·参数组合
        ·在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键
         字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、
         默认参数、可变参数、关键字参数和命名关键字参数。
        ·通过一个tuple和dict，你也可以调用上述函数：
    ·总结
        ·定义可变参数和关键字参数的语法：
            ·*args是可变参数，args接收的是一个tuple
            ·**kw是关键字参数，kw接收的是一个dict
        ·用函数时如何传入可变参数和关键字参数的语法：
            ·可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过
             *args传入：func(*(1, 2, 3))；
            ·关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw
             传入：func(**{'a': 1, 'b': 2})。
            ·使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯
             用法。
            ·命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
            ·定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将
            是位置参数。

4.递归函数
    ·使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。
    ·针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环
     语句的编程语言只能通过尾递归实现循环。
    ·Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。


三.高级特性
1.切片
    ·L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
        ·取索引为 0,1,2 的三个元素：
            >>> L[0:3] # 相当于L[:3]
            ['Michael', 'Sarah', 'Tracy']
        ·从索引1开始，取出2个元素：
            >>> L[1:3]
            ['Sarah', 'Tracy']
        ·倒数切片：
            >>> L[-2:]
            ['Bob', 'Jack']
            >>> L[-2:-1]
            ['Bob']
    ·L = list(range(100))
        ·前10个数，每两个取一个：
            >>> L[:10:2]
            [0, 2, 4, 6, 8]
        ·所有数，每5个取一个：
            >>> L[::5]
            [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80,
            85, 90, 95]
        ·原样复制一个list：
            >>> L[:]
            [0, 1, 2, 3, ..., 99]
    ·tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作
     的结果仍是tuple
         >>> (0, 1, 2, 3, 4, 5)[:3]
         (0, 1, 2)
    ·字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操
     作，只是操作结果仍是字符串：
         >>> 'ABCDEFG'[:3]
        'ABC'
        >>> 'ABCDEFG'[::2]
        'ACEG'
    ·不会发生 “string index out of range” 错误，根据实际情况自适应
        >>> s = '12345'
        >>> s[:100]
        '12345'

2.迭代
    ·如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，
     这种遍历我们称为迭代（Iteration）。
    ·只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代。因为dict的存储不
     是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。
        >>> d = {'a': 1, 'b': 2, 'c': 3}
        >>> for key in d:
        ...     print(key)
        ...
        a
        c
        b
    ·默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，
     如果要同时迭代key和value，可以用for k, v in d.items()。
    ·由于字符串也是可迭代对象，因此，也可以作用于for循环：
        >>> for ch in 'ABC':
        ...     print(ch)
        ...
        A
        B
        C
    ·通过collections模块的Iterable类型判断一个对象是可迭代对象
        >>> from collections import Iterable
        >>> isinstance('abc', Iterable) # str是否可迭代
        True
        >>> isinstance([1,2,3], Iterable) # list是否可迭代
        True
        >>> isinstance(123, Iterable) # 整数是否可迭代
        False
    ·如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一
     个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：
        >>> for i, value in enumerate(['A', 'B', 'C']):
        ...     print(i, value)
        ...
        0 A
        1 B
        2 C
    ·上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：
        >>> for x, y in [(1, 1), (2, 4), (3, 9)]:
        ...     print(x, y)
        ...
        1 1
        2 4
        3 9

3.列表生成式
    ·列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list
     的生成式。
    ·生成list[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        list(range(1, 11))
    ·生成[1*1, 2*2, 3*3, ..., 10*10]
        [x * x for x in range(1, 11)]
    ·写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来
    ·for循环后面还可以加上if判断
        ·筛选出仅偶数的平方：
            [x * x for x in range(1, 11) if x % 2 == 0]
    ·使用两层循环生成全排列
        [m + n for m in 'ABC' for n in 'XYZ']
    ·列出当前目录下的所有文件和目录名
        import os
        [d for d in os.listdir('.')]
    ·for循环可以同时使用两个甚至多个变量，列表生成式也可以使用两个变量来生成list
        d = {'x': 'A', 'y': 'B', 'z': 'C' }
        [k + '=' + v for k, v in d.items()]
    ·   L1 = ['Hello', 'World', 18, 'Apple', None]
        L2 = [x.lower() for x in L1 if isinstance(x, str)]

4.生成器
    ·通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。
     而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问
     前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。Python中，列表元素可以按
     照某种算法推算出来，不必创建完整的list，从而节省大量的空间这种一边循环一边计算的机
     制，称为生成器：generator。
    ·generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最
     后一个元素，没有更多的元素时，抛出StopIteration的错误。
    ·第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：
            >>> g = (x * x for x in range(10))
            >>> g
            <generator object <genexpr> at 0x1022ef630>
        ·如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：
            >>> next(g)
            0
            >>> next(g)
            1
            >>> next(g)
            4
        ·循环打印
            for n in g:
               print(n)
    ·定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再
     是一个普通函数，而是一个generator
            def odd():
                print('step 1')
                yield 1
                print('step 2')
                yield(3)
                print('step 3')*
                yield(5)
        ·函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的
         函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的
         yield语句处继续执行。
        ·调用该generator时，首先要生成一个generator对象，然后用next()函数不断获得下
         一个返回值，第4次调用next(o)时报错
    ·但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要
     拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：

5.迭代器
    ·可以直接作用于for循环的对象统称为可迭代对象：Iterable。其数据类型有以下几种：
        ·一类是集合数据类型，如list、tuple、dict、set、str等；
        ·一类是generator，包括生成器和带yield的generator function。
        ·可以使用isinstance()判断一个对象是否是Iterable对象：
            >>> from collections import Iterable
            >>> isinstance([], Iterable)
            True
    ·可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。
        ·生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到
         最后抛出StopIteration错误表示无法继续返回下一个值了。
        ·可以使用isinstance()判断一个对象是否是Iterator对象：
            >>> from collections import Iterator
            >>> isinstance((x fo
            r x in range(10)), Iterator)
            True
    ·生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。
    ·Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断
     返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有
     序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个
     数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。
    ·集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数
     获得一个Iterator对象。
    ·Python的for循环本质上就是通过不断调用next()函数实现的


四.函数式编程
1.高阶函数
    ·概念
        ·变量可以指向函数
        ·函数名也是变量
        ·传入函数
        ·   def add(x, y, f):
            return f(x) + f(y)
            print(add(-5, 6, abs))
    ·map/reduce
        ·map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator
         是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。
             def f(x):
                 return x * x
             r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
             # [1, 4, 9, 16, 25, 36, 49, 64, 81]
        ·reduce()把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参
         数，reduce把结果继续和序列下一个元素做累积计算
            ·from functools import reduce
            ·reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
    ·filter
        ·Python内建的filter()函数用于过滤序列。
        ·和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把
         传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该
         元素。
            def is_odd(n):
            return n % 2 == 1
            list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
        ·filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完
         成计算结果，需要用list()函数获得所有结果并返回list。
    ·sorted
        ·直接排序
            >>> sorted([36, 5, -12, 9, -21])
            [-21, -12, 5, 9, 36]
        ·接收一个key函数来实现自定义的排序
            >>> sorted([36, 5, -12, 9, -21], key=abs)
            [5, 9, -12, -21, 36]
        ·要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True
            >>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, \
            ... reverse=True)
            ['Zoo', 'Credit', 'bob', 'about']

2.返回函数
    ·函数作为返回值
        ·如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的
         结果，而是返回求和的函数：
            def lazy_sum(*args):
                def sum():
                    ax = 0
                    for n in args:
                        ax = ax + n
                    return ax
                return sum
        ·当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：
            >>> f = lazy_sum(1, 3, 5, 7, 9)
            >>> f
            <function lazy_sum.<locals>.sum at 0x101c6ed90>
        ·调用函数f时，才真正计算求和的结果：
            >>> f()
            25
        ·在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用
         外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都
         保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
        ·当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数。
    ·闭包
        ·注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函
         数后，其内部的局部变量还被新函数引用。
        ·另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。
                def count():
                    fs = []
                    for i in range(1, 4):
                        def f():
                             return i*i
                        fs.append(f)
                    return fs

                f1, f2, f3 = count()
            ·调用f1()，f2()和f3()的结果
                >>> f1()
                9
                >>> f2()
                9
                >>> f3()
                9
            ·全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数
             都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。
        ·返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
        ·如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量
         当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
             def count():
                 def f(j):
                     def g():
                         return j*j
                     return g
                 fs = []
                 for i in range(1, 4):
                     fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
                 return fs
    ·利用闭包和生成器返回一个计数器函数，每次调用它返回递增整数：
        def create_counter():
            def counter():
                def lt():
                    mm = 0
                    while True:
                        mm += 1
                        yield mm
                g = lt()

                def inner():
                    return next(g)
                return inner
            return counter()

        counterA = create_counter()
        print(type(counterA))
        print(counterA(), counterA(), counterA(), counterA(), counterA())
        # 1 2 3 4 5

3.匿名函数
    ·在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定
     义一个f(x)的函数外，还可以直接传入匿名函数：
         >>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
         [1, 4, 9, 16, 25, 36, 49, 64, 81]
    ·匿名函数lambda x: x * x实际上就是：
        def f(x):
        return x * x
    ·关键字lambda表示匿名函数，冒号前面的x表示函数参数。
    ·匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

4.装饰器（Decorator）
    ·由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。
            >>> def now():
            ...     print('2015-3-25')
            ...
            >>> f = now
            >>> f()
            2015-3-25
        ·函数对象有一个__name__属性，可以拿到函数的名字：
            >>> now.__name__
            'now'
            >>> f.__name__
            'now'
    ·现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望
     修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”
     （Decorator）。
        ·本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的
         decorator，可以定义如下：
             def log(func):
                 def wrapper(*args, **kw):
                     print('call %s():' % func.__name__)
                     return func(*args, **kw)
                 return wrapper
        ·观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函
         数。我们要借助Python的@语法，把decorator置于函数的定义处：
            @log
            def now():
                print('2015-3-25')
        ·调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：
            >>> now()
            call now():
            2015-3-25
        ·把@log放到now()函数的定义处，相当于执行了语句：
            now = log(now)
        ·由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是
         现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中
         返回的wrapper()函数。
        ·wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数
         的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。
    ·如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，比如，要
     自定义log的文本：
            def log(text):
                def decorator(func):
                    def wrapper(*args, **kw):
                        print('%s %s():' % (text, func.__name__))
                        return func(*args, **kw)
                    return wrapper
                return decorator
        ·这个3层嵌套的decorator用法如下：
            @log('execute')
            def now():
                print('2015-3-25')
        ·执行结果如下：
            >>> now()
            execute now():
            2015-3-25
        ·和两层嵌套的decorator相比，3层嵌套的效果是这样的：
            >>> now = log('execute')(now)
        ·首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now
         函数，返回值最终是wrapper函数。
    ·以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有
     __name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的
     'now'变成了'wrapper'：
            >>> now.__name__
            'wrapper'
        ·因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的
         __name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出
         错。
    ·不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的
     functools.wraps就是干这个事的。
        ·一个完整的不带参数的decorator的写法如下：
            import functools
            def log(func):
                @functools.wraps(func)
                def wrapper(*args, **kw):
                    print('call %s():' % func.__name__)
                    return func(*args, **kw)
                return wrapper
        ·带参数的decorator：
            import functools
            def log(text):
                def decorator(func):
                    @functools.wraps(func)
                    def wrapper(*args, **kw):
                        print('%s %s():' % (text, func.__name__))
                        return func(*args, **kw)
                    return wrapper
                return decorator

5.偏函数（Partial function）
    ·通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。
        ·int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换
            >>> int('12345')
            12345
        ·但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制
         的转换：
            >>> int('12345', base=8)
            5349
            >>> int('12345', 16)
            74565
        ·假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想
         到，可以定义一个int2()的函数，默认把base=2传进去：
            ·def int2(x, base=2):
                 return int(x, base)
            ·>>> int2('1000000')
             64
             >>> int2('1010101')
             85
    ·functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直
     接使用下面的代码创建一个新的函数int2：
        >>> import functools
        >>> int2 = functools.partial(int, base=2)
        >>> int2('1000000')
        64
        >>> int2('1010101')
        85
    ·所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是
     设置默认值），返回一个新的函数，调用这个新函数会更简单。
    ·创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数
        ·int2('10010')
         相当于
         kw = { 'base': 2 }
         int('10010', **kw)
        ·max2 = functools.partial(max, 10)
         max2(5, 6, 7)
         相当于
         args = (10, 5, 6, 7)
         max(*args)


五.模块
1.概念
    ·任何模块代码的第一个字符串都被视为模块的文档注释
    ·一个.py文件就称之为一个模块（Module）。
    ·为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。java
     中文件夹与包等价。python中需要有_init_.py。
        ·一个abc.py的文件就是一个名字叫abc的模块，一个xyz.py的文件就是一个名字叫xyz的
         模块。
        ·假设我们的abc和xyz这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模
         块，避免冲突。方法是选择一个顶层包名，比如mycompany，按照如下目录存放：
            mycompany
            ├─ __init__.py
            ├─ abc.py
            └─ xyz.py
        ·现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了
         mycompany.xyz。
    ·每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python
     就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python
     代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。
    ·注意事项
        ·模块名要遵循Python变量命名规范，不要使用中文、特殊字符；
        ·模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在
         Python交互环境执行import abc，若成功则说明系统存在此模块。

2.使用模块
    ·当我们在命令行运行模块文件时，Python解释器把该模块中的一个特殊变量__name__置为
     __main__
    ·sys模块
        ·import sys
        ·导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模
         块的所有功能。
        ·sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因
         为第一个参数永远是该.py文件的名称
            ·运行python3 hello.py获得的sys.argv就是['hello.py']
    ·在import的时候就会执行里面的代码
        >>> import hello2.py
        hello helllow.py
    ·作用域
        ·在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用
         ，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。
        ·正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等
        ·类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的
         __author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量
         __doc__访问，我们自己的变量一般不要用这种变量名
        ·类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比
         如_abc，__abc等
        ·private函数和变量“不应该”被直接引用，而不是“不能”被直接引用。Python并没有一
         种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用
         private函数或变量。

3.安装第三方模块
    ·在Python中，安装第三方模块，是通过包管理工具pip完成的。
    ·Mac或Linux上有可能并存Python 3.x和Python 2.x，因此对应的pip命令是pip3。
    ·在使用Python时，我们经常需要用到很多第三方库，例如，上面提到的Pillow，以及MySQL
     驱动程序，Web框架Flask，科学计算Numpy等。用pip一个一个安装费时费力，还需要考虑兼
     容性。我们推荐直接使用Anaconda，这是一个基于Python的数据处理和科学计算平台，它已
     经内置了许多非常有用的第三方库，我们装上Anaconda，就相当于把数十个第三方模块自动
     安装好了，非常简单易用。
    ·当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就
     会报错：
    ·默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路
     径存放在sys模块的path变量中：
        ·>>> import sys
         >>> sys.path
         ['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip',
         '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', ...,
         '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/
         site-packages']
    ·如果我们要添加自己的搜索目录，有两种方法：
        ·直接修改sys.path，添加要搜索的目录：
         >>> import sys
         >>> sys.path.append('/Users/michael/my_py_scripts')
        ·设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方
         式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜
         索路径不受影响。


六.面向对象编程
1.类和实例
    ·在Python中，定义类是通过class关键字：
        ·class Student(object):
             pass
    ·class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表
     示该类是从哪个类继承下来的。通常，如果没有合适的继承类，就使用object类，这是所有
     类最终都会继承的类。
    ·定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+
     ()实现的：
        ·>>> bart = Student()
         >>> bart
         <__main__.Student object at 0x10a67a590>
         >>> Student
         <class '__main__.Student'>
    ·可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：
        ·>>> bart.name = 'Bart Simpson'
         >>> bart.name
         'Bart Simpson'
    ·由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性
     强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score
     等属性绑上去：
        ·class Student2(object):
             def __init__(self, name, score):
                 self.name = name
                 self.score = score
    ·__init__的第一个参数永远是实例变量self

2.数据封装
    ·class Student2(object):
         def __init__(self, name, score):
             self.name = name
             self.score = score

         def print_score(self):
             print('%s: %s' % (self.name, self.score))
    ·和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽
     然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：
        >>> bart = Student('Bart Simpson', 59)
        >>> lisa = Student('Lisa Simpson', 87)
        >>> bart.age = 8
        >>> bart.age
        8
        >>> lisa.age
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        AttributeError: 'Student' object has no attribute 'age'

3.访问限制
    ·从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性。
    ·如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实
     例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不
     能访问
    ·如果外部代码要获取name和score，可以给Student类增加get_name和get_score这样的方法
    ·要允许外部代码修改score，可以再给Student类增加set_score方法
    ·在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是
     是特殊变量，特殊变量是可以直接访问的。
    ·以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按
     照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我
     视为私有变量，不要随意访问”。
    ·bart.__name = 'New Name'
     表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的
     __name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了其他变量名，
     而外部代码给bart新增了一个__name变量。

4.继承和多态
    ·class Animal(object):
         def run(self):
             print('Animal is Running')

     class Dog(Animal):
         pass
    ·“开闭”原则：
        ·对扩展开放：允许新增Animal子类；
        ·对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。
    ·动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。它并不要求严格的继承体系，
     一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。
    ·Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方
     法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。
     许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以
     传入任何实现了read()方法的对象。

5.获取对象信息（类似JavaScript）
    ·使用type()
        ·基本类型
            >>> type(123)
            <class 'int'>
            >>> type('str')
            <class 'str'>
            >>> type(None)
            <type(None) 'NoneType'>
        ·函数或者类
            >>> type(abs)
            <class 'builtin_function_or_method'>
            >>> type(a)
            <class '__main__.Animal'>
        ·判断对象是否为函数
            >>> import types
            >>> def fn():
            ...     pass
            ...
            >>> type(fn)==types.FunctionType
            True
            >>> type(abs)==types.BuiltinFunctionType
            True
            >>> type(lambda x: x)==types.LambdaType
            True
            >>> type((x for x in range(10)))==types.GeneratorType
            True
    ·使用isinstance() (优先使用)
        ·object -> Animal -> Dog -> Husky
        ·形式：isinstance(Husky(), Husky)
        ·一个类的对象是所有该类父类及该类本身的实例，返回True
        ·还可以判断一个变量是否是某些类型中的一种
            >>> isinstance([1, 2, 3], (list, tuple))
            True
            >>> isinstance((1, 2, 3), (list, tuple))
            True
    ·使用dir()
        ·如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串
         的list，比如，获得一个str对象的所有属性和方法
        ·类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。
         在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内
         部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的：
            >>> len('ABC')
            3
            >>> 'ABC'.__len__()
            3
        ·我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法
        ·剩下的都是普通属性或方法，比如lower()返回小写的字符串
        ·配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：
            ·getattr(obj, 'y')
            ·setattr(obj, 'y', 19)
            ·hasattr(obj, 'y')
            ·如果试图获取不存在的属性，会抛出AttributeError的错误
            ·可以传入一个default参数，如果属性不存在，就返回默认值
                ·getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
            ·只有在不知道对象信息的时候，我们才会去获取对象信息
            ·假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法
             ，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了
             用场。
                 def readImage(fp):
                 if hasattr(fp, 'read'):
                     return readData(fp)
                 return None

6.实例属性和类属性
    ·由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通
     过实例变量，或者通过self变量：
        class Student(object):
            def __init__(self, name):
                self.name = name

        s = Student('Bob')
        s.score = 90
    ·如果Student类本身需要绑定一个属性，可以直接在class中定义属性。这种属性是类属性，
     归Student类所有。当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都
     可以访问到。（相当于java类中被static修饰的属性）
    ·在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性
     将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。
    ·del s.name: 删除实例属性name
    ·del Student.name: 删除类属性name


七.面向对象高级编程
1.使用__slots__
    ·正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定
     任何属性和方法
        ·实例绑定属性
            s = Student()
            s.name = 'Michael'
        ·实例绑定方法
            s.set_age = MethodType(set_age, s)  # 函数要先转化为方法
    ·使用__slots__
        ·作用：限制实例的属性
        ·class Student(object):
             __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
        ·使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类
         是不起作用的。除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自
         身的__slots__加上父类的__slots__。

2.使用@property
    ·@property装饰器就是负责把一个方法变成属性调用的
        class Student(object):

            @property
            def score(self):
                return self._score

            @score.setter
            def score(self, value):
                if not isinstance(value, int):
                    raise ValueError('score must be an integer!')
                if value < 0 or value > 100:
                    raise ValueError('score must between 0 ~ 100!')
                self._score = value

            @score.deleter
            def score(self, value):
                del self._score

    ·把一个getter方法变成属性，只需要加上@property就可以了。
        ·只有@property表示只读。
        ·同时有@property和@x.setter表示可读可写。
        ·同时有@property和@x.setter和@x.deleter表示可读可写可删除。
    ·还可以定义只读属性。只定义getter方法，不定义setter方法就是一个只读属性。
    ·@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要
     的检查，这样，程序运行时就减少了出错的可能性。

3.多重继承
    ·在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。
     但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继
     承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。
    ·为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和
     FlyableMixIn。
    ·已存在Mammal、 RunnableMixIn和 CarnivorousMixIn三个类
        class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
            pass
    ·只允许单一继承的语言（如Java）不能使用MixIn的设计
    ·MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继
     承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。

4.定制类
    ·类似__slots__这种形如__xxx__的变量或者函数名在Python中有特殊用途。
    ·__slots__属性
    ·__len__()方法能让class作用于len()函数。
    ·__str__与__repr__
        ·设置直接打印实例时的控制台输出
        ·代码：
            >>> class Student(object):
            ...     def __init__(self, name):
            ...         self.name = name
            ...     def __str__(self):
            ...         return 'Student object (name: %s)' % self.name
            ...
            >>> s = Student('Michael')
            >>> print(s)
            Student object (name: Michael)
            >>> s
            <__main__.Student object at 0x109afb310>
        ·直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回
         用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，
         __repr__()是为调试服务的。
        ·解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的
         ，所以，有个偷懒的写法：
             class Student(object):
                def __init__(self, name):
                    self.name = name
                def __str__(self):
                    return 'Student object (name=%s)' % self.name
                __repr__ = __str__
        ·如果实现了__repr__而没有定义__str__，那么对象将会表现出__str__ = __repr__
    ·__iter__
        ·如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个
         __iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该
         迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出
         循环。
            class Fib(object):
                def __init__(self):
                    self.a, self.b = 0, 1  # 初始化两个计数器a，b

                def __iter__(self):
                    return self  # 实例本身就是迭代对象，故返回自己

                def __next__(self):
                    self.a, self.b = self.b, self.a + self.b  # 计算下一个值
                    if self.a > 100000:  # 退出循环的条件
                        raise StopIteration()
                    return self.a  # 返回下一个
    ·__getitem__
        ·Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是
         不行。要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：
            def __getitem__(self, n):
                a, b = 1, 1
                for x in range(n):
                    a, b = b, a + b
                return a
        ·实现切片（未对step参数和负数做处理）
            class Fib(object):
                def __getitem__(self, n):
                    if isinstance(n, int): # n是索引
                        a, b = 1, 1
                        for x in range(n):
                            a, b = b, a + b
                        return a
                    if isinstance(n, slice): # n是切片
                        start = n.start
                        stop = n.stop
                        if start is None:
                            start = 0
                        a, b = 1, 1
                        L = []
                        for x in range(stop):
                            if x >= start:
                                L.append(a)
                            a, b = b, a + b
                        return L
        ·与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有
         一个__delitem__()方法，用于删除某个元素。
        ·通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么
         区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。
    ·__getattr__
        ·正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。
        ·要避免这个错误，除了可以加上一个相应属性外，Python还有另一个机制，那就是写一
         个__getattr__()方法，动态返回一个属性。当调用不存在的属性时，Python解释器会
         试图调用__getattr__(self, 'score')来尝试获得属性。
            def __getattr__(self, attr):
                if attr == 'score':
                    return 99
        ·也可以返回函数（通过instance.age()调用）
            def __getattr__(self, attr):
                if attr == 'age':
                    return lambda: 25
        ·只有在没有找到属性的情况下，才调用__getattr__。默认返回None。要让class只响应
         特定的几个属性，我们就要按照约定，抛出AttributeError的错误：
             class Student(object):
                def __getattr__(self, attr):
                    if attr=='age':
                        return lambda: 25
                    raise AttributeError('\'Student\' object has no attribute
                     \'%s\'' % attr)
        ·链式调用
            class Chain(object):

                def __init__(self, path=''):
                    self._path = path

                def __getattr__(self, path):
                    return Chain('%s/%s' % (self._path, path))

                def __str__(self):
                    return self._path

                __repr__ = __str__
    ·__call__
        ·任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。
            class Student(object):
                def __init__(self, name):
                    self.name = name

                def __call__(self, *args, **kwargs):
                    print('My name is %s.' % self.name)


            s = Student('Michael')
            s()  # My name is Michael.
        ·__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所
         以完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没有根本的区别。
        ·怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能
         被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有
         __call__()的类实例：
             >>> callable(Student())
             True
             >>> callable(max)
             True
             >>> callable([1, 2, 3])
             False
             >>> callable(None)
             False
             >>> callable('str')
             False

5.使用枚举类
    ·from enum import Enum

     Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',
     'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

     for name, member in Month.__members__.items():
         print(name, '=>', member, ',', member.value)
    ·如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：
        from enum import Enum, unique

            @unique
            class Weekday(Enum):
                Sun = 0 # Sun的value被设定为0
                Mon = 1
                Tue = 2
                Wed = 3
                Thu = 4
                Fri = 5
                Sat = 6
    ·@unique装饰器可以帮助我们检查保证没有重复值。
    ·访问这些枚举类型可以有若干种方法
        >>> day1 = Weekday.Mon
        >>> print(day1)
        Weekday.Mon
        >>> print(Weekday.Tue)
        Weekday.Tue
        >>> print(Weekday['Tue'])
        Weekday.Tue
        >>> print(Weekday.Tue.value)
        2
        >>> print(day1 == Weekday.Mon)
        True
        >>> print(day1 == Weekday.Tue)
        False
        >>> print(Weekday(1))
        Weekday.Mon
        >>> print(day1 == Weekday(1))
        True
        >>> Weekday(7)
        Traceback (most recent call last):
        ...
        ValueError: 7 is not a valid Weekday
        >>> for name, member in Weekday.__members__.items():
        ...     print(name, '=>', member)
        ...
        Sun => Weekday.Sun
        Mon => Weekday.Mon
        Tue => Weekday.Tue
        Wed => Weekday.Wed
        Thu => Weekday.Thu
        Fri => Weekday.Fri
        Sat => Weekday.Sat

6.使用元类


八.错误、调试和测试
1.错误处理
    ·try
        ·实例
            try:
                print('try...')
                r = 10 / int('2')
                print('result:', r)
            except ValueError as e:
                print('ValueError:', e)
            except ZeroDivisionError as e:
                print('ZeroDivisionError:', e)
            else:
                print('no error!')
            finally:
                print('finally...')
            print('END')
        ·当我们认为某些代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后
         续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except
         后，如果有finally语句块，则执行finally语句块，至此，执行完毕。
        ·与java相同，当错误发生时，后续语句print('result:', r)不会被执行，except由于
         捕获到ZeroDivisionError，因此被执行。最后，finally语句被执行。然后，程序继
         续按照流程往下走。
        ·与java不同，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发
         生时，会自动执行else语句：
        ·与java相同，Python的错误其实也是class，所有的错误类型都继承自BaseException
         ，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打
         尽”。
        ·不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。
         java则需要在前一个层次throws Exception下一层才能捕捉到。
    ·调用栈
        ·如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信
         息，然后程序退出。
    ·记录错误
        ·except Exception as e:
             logging.exception(e)
        ·Python内置的logging模块可以非常容易地记录错误信息：
        ·同样是出错，但程序打印完错误信息后会继续执行，并正常退出：
        ·通过配置，logging还可以把错误记录到日志文件里，方便事后排查。
    ·抛出错误
        ·如果要抛出错误，首先根据需要，可以定义一个错误的class，选择好继承关系，然后，
         用raise语句抛出一个错误的实例：
            class FooError(ValueError):
                 pass

            def foo(s):
                 n = int(s)
                 if n==0:
                    raise FooError('invalid value: %s' % s)
                 return 10 / n

            foo('0')
        ·尽量使用Python内置的错误类型。
        ·另一种错误处理的方式：
            def foo(s):
                n = int(s)
                if n==0:
                    raise ValueError('invalid value: %s' % s)
                return 10 / n

            def bar():
                try:
                    foo('0')
                except ValueError as e:
                    print('ValueError!')
                    raise

            bar()
        ·捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该
         错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。

2.调试
    ·print
        ·第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看
    ·assert
        ·凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：
            def foo(s):
                n = int(s)
                assert n != 0, 'n is zero!'
                return 10 / n

            def main():
                foo('0')
        ·程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释
         器时可以用-O参数来关闭assert。关闭后，你可以把所有的assert语句当成pass来看。
    ·logging
        ·把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可
         以输出到文件：
            import logging

            s = '0'
            n = int(s)
            logging.info('n = %d' % n)
            print(10 / n)
         ·
3.单元测试
4.文档测试


九.IO编程
1.文件读写
    ·读UTF-8文本文件
        ·要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标
         示符
            try:
                f = open('test.txt', 'r')
                print(f.read())
            finally:
                if f:
                    f.close()  # 文件使用完毕后必须关闭
        ·如果文件不存在，open()函数就会抛出一个IOError的错误
        ·为了简化步骤，Python引入了with语句来自动帮我们调用close()方法.这和前面的try
         ... finally是一样的，但是代码更加简洁，并且不必调用f.close()方法。
            with open('test.txt', 'r') as f:
                print(f.read())
        ·调用read()会一次性读取文件的全部内容。可以反复调用read(size)方法，每次最多读
         取size个字节的内容。
        ·调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返
         回list。
    ·file-like object
        ·像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like
         Object。除了file外，还可以是内存的字节流、网络流、自定义流等等。file-like
         Object不要求从特定类继承，只要写个read()方法就行。
        ·StringIO就是在内存中创建的file-like Object，常用作临时缓冲。
    ·读二进制文件
        ·前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比
         如图片、视频等等，用'rb'模式打开文件即可。
            f = open('onePunch.jpeg', 'rb')
    ·读其他字符编码的文本文件
        ·要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数
            f = open('gbk.txt', 'r', encoding='gbk')
        ·遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可
         能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表
         示如果遇到编码错误后如何处理。最简单的方式是直接忽略。
            f = open('gbk.txt', 'r', encoding='gbk', errors='ignore')
    ·写文件
        ·写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表
         示写文本文件或写二进制文件：
        ·你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写
         文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再
         慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。
         忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。
        ·如果我们希望追加到文件末尾，可以传入'a'以追加（append）模式写入。

2.StringIO和BytesIO
    ·StringIO
        ·数据读写不一定是文件，也可以在内存中读写。StringIO顾名思义就是在内存中读写
         str。要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入
         即可.
             >>> from io import StringIO
             >>> f = StringIO()
             >>> f.write('hello')
             5
             >>> f.write(' ')
             1
             >>> f.write('world!')
             6
             >>> print(f.getvalue())
             hello world!
        ·getvalue()方法用于获得写入后的str。
        ·要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：
            >>> from io import StringIO
            >>> f = StringIO('Hello!\nHi!\nGoodbye!')
            >>> while True:
            ...     s = f.readline()
            ...     if s == '':
            ...         break
            ...     print(s.strip())
            ...
            Hello!
            Hi!
            Goodbye!
    ·BytesIO
        ·StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实
         现了在内存中读写bytes
            >>> from io import BytesIO
            >>> f = BytesIO()
            >>> f.write('中文'.encode('utf-8'))
            6
            >>> print(f.getvalue())
            b'\xe4\xb8\xad\xe6\x96\x87'
        ·此时写入的不是str，而是经过UTF-8编码的bytes。
        ·和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取。
            >>> from io import BytesIO
            >>> f = BytesIO(b'\xe4\xb8\xad\xe6\x96\x87')
            >>> f.read()
            b'\xe4\xb8\xad\xe6\x96\x87'

3.操作文件和目录
    ·Python内置的os模块可以直接调用操作系统提供的接口函数。
    ·查看系统类型
        >>> import os
        >>> os.name # 操作系统类型 如果是posix，说明系统是Linux、Unix或Mac OS X，
        >>>         # 如果是nt，就是Windows系统。
        'nt'
    ·操作文件和目录
        ·实例     ·在Linux/Unix/Mac下，os.path.join()返回这样的字符串：
            >>> os.path.abspath('.')
            '/Users/michael'
            # 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
            >>> os.path.join('/Users/michael', 'testdir')
            '/Users/michael/testdir'
            # 然后创建一个目录:
            >>> os.mkdir('/Users/michael/testdir')
            # 删掉一个目录:
            >>> os.rmdir('/Users/michael/testdir')
        ·把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以
         正确处理不同操作系统的路径分隔符。
            ·在Linux/Unix/Mac下，os.path.join()返回这样的字符串：
                part-1/part-2
            ·在Windows下会返回这样的字符串：
                part-1\part-2
        ·同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数
         ，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名
             >>> os.path.split('/Users/michael/testdir/file.txt')
             ('/Users/michael/testdir', 'file.txt')
        ·os.path.splitext()可以直接让你得到文件扩展名
            >>> os.path.splitext('/path/to/file.txt')
            ('/path/to/file', '.txt')
        ·这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。
        ·对文件重命名:
            os.rename('test.txt', 'test.py')
        ·删掉文件:
            os.remove('test.py')
    ·shutil
        ·是os模块的补充。
        ·复制文件
            copyfile()
        ·列出当前目录下的所有目录
            >>> [x for x in os.listdir('.') if os.path.isfile(x) and os.path.
                splitext(x)[1]=='.py']
            ['apis.py', 'config.py', 'models.py', 'pymonitor.py', 'test_db.py',
                'urls.py', 'wsgiapp.py']

4.序列化
    ·在程序运行的过程中，所有的变量都是在内存中。我们把变量从内存中变成可存储或传输的过
     程称之为序列化
    ·pickle.dumps()方法吧任意队形序列化成一个bytes，然后就可以把这个bytes写入文件。
         >>> import pickle
         >>> d = dict(name='Bob', age=20, score=88)
         >>> pickle.dumps(d)
         b'\x80\x03}q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq
         \x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.'
    ·也可以用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object
        >>> f = open('dump.txt', 'wb')
        >>> pickle.dump(d, f)
        >>> f.close()
    ·当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()
     方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反
     序列化出对象。
        >>> f = open('dump.txt', 'rb')
        >>> d = pickle.load(f)
        >>> f.close()
        >>> d
        {'age': 20, 'score': 88, 'name': 'Bob'}

5.JSON
    ·JSON和Python内置的数据类型对应如下
        JSON类型    Python类型
        {} 	        dict
        [] 	        list
        "string"    str
        1234.56 	int或float
        true/false 	True/False
        null 	    None
    ·Python对象转JSON
        >>> import json
        >>> d = dict(name='Bob', age=20, score=88)
        >>> json.dumps(d)
        '{"age": 20, "score": 88, "name": "Bob"}'
    ·dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON
     写入一个file-like Object。
    ·要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串
     反序列化，后者从file-like Object中读取字符串并反序列化
        >>> json_str = '{"age": 20, "score": 88, "name": "Bob"}'
        >>> json.loads(json_str)
        {'age': 20, 'score': 88, 'name': 'Bob'}
    ·由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str与JSON的字符
     串之间转换。

6.class与JSON转换
    ·默认情况下，dumps()方法不知道如何将Student实例变为一个JSON的{}对象。
    ·可选参数default就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为Student
     专门写一个转换函数，再把函数传进去即可：
    ·通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量。也有少数
     例外，比如定义了__slots__的class。
    ·同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出
     一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例
    ·实例：
        def student2dict(std):
            return  {
                'name': std.name,
                'age': std.age,
                'score': std.score
            }


        def dict2student(d):
            return Student(d['name'], d['age'], d['score'])


        s = Student('Bob', 20, 88)
        # Student实例首先被student2dict()函数转换成dict，然后再被顺利序列化为JSON
        print(json.dumps(s, default=student2dict))

        json_str = json.dumps(s, default=lambda obj: obj.__dict__)
        print(json_str)
        print(json.loads(json_str, object_hook=dict2student))

十.进程和线程


十一.正则表达式


十二.常用内建模块


十三.常用第三方模块
